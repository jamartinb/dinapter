/*
 * This file is part of Dinapter.
 *
 *  Dinapter is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Dinapter is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  (C) Copyright 2007 José Antonio Martín Baena
 *  
 *  José Antonio Martín Baena <jose.antonio.martin.baena@gmail.com>
 *  Ernesto Pimentel Sánchez <ernesto@lcc.uma.es>
 */
package dinapter.specificator.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;

import dinapter.behavior.BehaviorGraph;
import dinapter.behavior.BehaviorNode;
import dinapter.behavior.BehaviorNode.BehaviorNodeType;

/**
 * This is an utility class which returns the minimal sets of actions required in order
 * to fully complete any traces generated by the <code>SWITCHs</code> of a component.
 * In the case of the <code>PICK</code> it will be added the minimal set of its
 * branches. 
 * @author José Antonio Martín Baena
 *
 * @param <B> {@link BehaviorNode} class which the component is made of.
 * @param <BG> {@link BehaviorGraph} class which represents the component.
 */
public class SolutionActions<B extends BehaviorNode, BG extends BehaviorGraph<B>> {
	
	private static final Logger log = Logger.getLogger(SolutionActions.class);
	
	private final List<B> EMPTY_LIST = Collections.emptyList();
	
	/**
	 * This set will contain all the explored traces.
	 */
	private final Set<List<B>> traceSet;
	
	/**
	 * The number of traces to display in {@link #DEBUG_MODE} (<code>== true</code>).
	 */
	private static final int DEBUG_TRACE_LIMIT = 20;
	
	/**
	 * An approximate count of the <code>HashSet<Set<B>></code> instantiated.
	 */
	private static int setsCount = 0;
	
	/**
	 * When <code>DEBUG_MODE</code> is <code>true</code> it will display a list
	 * of all the explored traces.
	 */
	private static final boolean DEBUG_MODE = false;
	
	/**
	 * Maximum length of the trace. Once a traces reaches this limit it
	 * won't continue anymore.
	 */
	private static final int MAX_TRACE_LENGTH = 50;
	
	/**
	 * The maximum amount of time allowed to depthen in the trace.
	 */
	private static final long TIMEOUT = 30000; //ms.
	
	/**
	 * The time when the search for solution sets start.
	 */
	private long startTime = -1;
	
	/**
	 * It instantiates this class.
	 */
	public SolutionActions() {
		traceSet = DEBUG_MODE?new HashSet<List<B>>():null;
	}
	
	public Set<Set<B>> getPossibleRequiredActions(BG behavior) {
		return getAllPossibleJoins(new LinkedList<Set<B>>(getMinimalRequiredActions(behavior)));
	}
	
	protected static <T> Set<Set<T>> getAllPossibleJoins(List<Set<T>> sets) {
		if (sets.isEmpty()) {
			return new HashSet<Set<T>>();
		} else if (sets.size() == 1) {
			return new HashSet<Set<T>>(sets);
		} else {
			Set<Set<T>> a, b, toReturn;
			a = new HashSet<Set<T>>(sets.subList(0, 1));
			b = getAllPossibleJoins(sets.subList(1, sets.size()));
			// We copy/clone the sets because cartesianProduct might modify them.
			// @todo I don't know why the first copy is needed but, otherwise, it will return repeated element inside the set.
			toReturn = copy(cartesianProduct(copy(a), copy(b)));
			toReturn.addAll(a);
			toReturn.addAll(b);
			return toReturn;
		}
	}
	
	private static <T> Set<Set<T>> copy(Set<Set<T>> toCopy) {
		Set<Set<T>> toReturn = new HashSet<Set<T>>(toCopy.size());
		for (Set<T> set:toCopy) {
			toReturn.add(new HashSet<T>(set));
		}
		return toReturn;
	}

	/**
	 * Returns the minimal sets of actions required to be supported by an
	 * adaptor in order to always complete the execution of the component.
	 * @param behavior Behavior of the component.
	 * @return A set of sets which contains the alternative minimals.
	 */
	public Set<Set<B>> getMinimalRequiredActions(BG behavior) {
		if (DEBUG_MODE) {
			traceSet.clear();
		}
		startTime = System.currentTimeMillis();
    	Set<Set<B>> toReturn = getMinimalRequiredActions(behavior,DEBUG_MODE?EMPTY_LIST:null, 0, behavior.getStartNode());
    	if (DEBUG_MODE) {
    		printTraces(traceSet);
    		log.debug("=== No more traces ===");
    	}
    	return toReturn;
    }

	private void printTraces(Collection<List<B>> traceSet) {
		List<List<B>> traces = new ArrayList<List<B>>(traceSet);
		Collections.sort(traces, new Comparator<List<B>>() {

			@Override
			public int compare(List<B> o1, List<B> o2) {
				int toReturn = o1.size() - o2.size();
				if (toReturn == 0) {
					return o1.toString().compareToIgnoreCase(o2.toString());
				} else {
					return toReturn;
				}
			}
			
		});
		log.info("------ Traces: -------");
		int count = 0;
		for (List<B> trace:traces) {
			if (count++ >= DEBUG_TRACE_LIMIT) {
				log.info("[TRACE LIMIT REACHED]");
				break;
			}
			log.info(trace);
		}
	}
	
	/*
	 * Returns the minimal sets of actions requried to be supported by an
	 * adaptor in order to always complete the execution of the component.
	 * @param behavior Behavior of the component.
	 * @param trace Trace of actions processed so far.
	 * @param newAction Action to be included at the end of the trace.
	 * @return A set of sets which contains the alternative minimals.
	 *-/
	protected Set<Set<B>> getRequiredActions(BG behavior, LinkedList<B> trace, B newAction) {
		LinkedList<B> newTrace = new LinkedList<B>(trace);
		newTrace.add(newAction);
		return getRequiredActions(behavior, newTrace);
	}*/
	
	/**
	 * Returns the minimal sets of actions required to be supported by an
	 * adaptor in order to always complete the execution of the component.
	 * @param behavior Behavior of the component.
	 * @param traceLength The number of actions processed in the current trace.
	 * @param lastAction The last processed action. It will be included in the required actions set.
	 * @return A set of sets which contains the alternative minimals. It might be <code>null</code>
	 * if the {@link #MAX_TRACE_LENGTH} or {@link TIMEOUT} limit is reached.
	 */
	@SuppressWarnings("unchecked")
    protected Set<Set<B>> getMinimalRequiredActions(BG behavior
    		, List<B> trace, int traceLength, B lastAction) {
		if (traceLength >= MAX_TRACE_LENGTH) {
			return null;
		} else if (System.currentTimeMillis() - startTime >= TIMEOUT) {
			log.warn("Reached the timeout");
			return null;
		}
		B requiredAction = null;
		List<B> newTrace = getTrace(trace, lastAction); 
		if ((lastAction.getType() == BehaviorNodeType.SEND)
				|| (lastAction.getType() == BehaviorNodeType.RECEIVE)) {
			requiredAction = lastAction;
		}
		Set<Set<B>> toReturn = null;
	    if (lastAction.getType() == BehaviorNode.BehaviorNodeType.PICK) {
	    	Collection<B> children = behavior.getChildren(lastAction);
	    	Iterator<B> childrenIterator = children.iterator();
	    	while ((toReturn == null) && childrenIterator.hasNext()) {
	    		toReturn = getMinimalRequiredActions(behavior,newTrace,traceLength+1,childrenIterator.next());
	    	}
	    	while (childrenIterator.hasNext()) {
	    		Set<Set<B>> followingRequiredActions = getMinimalRequiredActions(behavior, newTrace,traceLength+1,childrenIterator.next());
	    		if (followingRequiredActions != null) {
	    			toReturn.addAll(followingRequiredActions);
	    		}
    		}
    	} else if (lastAction.getType() == BehaviorNode.BehaviorNodeType.IF) {
    		Collection<B> children = behavior.getChildren(lastAction);
    		// Proper place to declare results;
    		LinkedList<Set<Set<B>>> results = new LinkedList<Set<Set<B>>>();
    		for (B child:children) {
    			Set<Set<B>> result = getMinimalRequiredActions(behavior, newTrace,traceLength+1,child);
    			if ((result != null) && !result.isEmpty())
    				results.add(result);
    		}
    		if (results.size() > 1) {
    			toReturn = cartesianProduct(results);
    		} else if (results.size() == 1) {
    			toReturn = results.getFirst();
    		} // toReturn == null otherwise.
    		results = null; // Free for the gc.
    	} else {
    		Collection<B> children = behavior.getChildren(lastAction);
    		int childrenSize = children.size();
    		if (childrenSize > 1) {
    			throw new IllegalArgumentException("A regular behavior node with more than one children: "+lastAction);
    		} else if (childrenSize == 1) {
    			toReturn = getMinimalRequiredActions(behavior, newTrace, traceLength+1,children.iterator().next());
    		} else if (lastAction.getType() == BehaviorNodeType.EXIT) { // childrenSize == 0
    			toReturn = createEmptySet();
    		}
    	}
	    if ((toReturn != null) && (requiredAction != null)) {
		    if (toReturn.isEmpty()) {
		    	Set<B> aux = new HashSet<B>(1);
		    	aux.add(requiredAction);
		    	toReturn.add(aux);
		    	setsCount++;
		    } else {
		    	toReturn = cartesianProduct(requiredAction,toReturn);
		    }
	    }
    	//return removeSuperSets(toReturn);
    	return toReturn;
    }
	
	private List<B> getTrace(List<B> previousTrace, B lastAction) {
		if (DEBUG_MODE) {
			List<B> toReturn = new ArrayList<B>(previousTrace.size()+1);
			toReturn.addAll(previousTrace);
			toReturn.add(lastAction);
			traceSet.add(toReturn);
			return toReturn;
		} else {
			return null;
		}
	}
	
	private Set<Set<B>> createEmptySet() {
		if (++setsCount % 100 == 0) {
			log.trace("Reached "+setsCount+" sets.");
		}
		return new HashSet<Set<B>>();
	}
	
	/**
	 * <p>Cartesian product of a list of sets.</p> 
	 * <p><b>WARNING:</b> it might modify the given sets.</p>
	 * @param <T> The class of the values of the inner sets.
	 * @param sets List of sets of sets to be multiplied.
	 * @return The cartesian product of the list.
	 */
	public static <T> Set<Set<T>> cartesianProduct(List<Set<Set<T>>> sets) {
		if (sets.size() < 2) {
			throw new IllegalArgumentException("The cartesian product must have more than two arguments.");
		}
		Set<Set<T>>toReturn = cartesianProduct(sets.get(0), sets.get(1));
		for (int i = 2; i < sets.size(); i++) {
			toReturn = cartesianProduct(toReturn, sets.get(i));
		}
		return toReturn;
	}
	
	/**
	 * <p>Cartesian product of two sets of sets. It is optimized in case of one
	 * of the sets with a single inner set so the other argument will be modified
	 * and returned as result.</p>
	 * <p><b>WARNING:</b> it might modify the given sets.</p>
	 * @param <T> The class of the values of the inner sets.
	 * @param a A product set.
	 * @param b Another product set.
	 * @return The cartesian product of sets <code>a</code> and <code>b</code>.
	 */
	public static <T> Set<Set<T>> cartesianProduct(Set<Set<T>> a, Set<Set<T>> b) {
		// @todo This method should be refactorized to a different class.
		if (a.isEmpty()) {
			return b;
		} else if (b.isEmpty()) {
			return a;
		} else if ((b.size() == 1) && (a.size() > 1)) {
			return cartesianProduct(b, a);
		} else if ((a != b) && (a.size() == 1)) {
			Set<T> aSet = a.iterator().next();
			if (aSet.size() == 1) {
				return cartesianProduct(aSet.iterator().next(), b);
			} else {
				for (Set<T> bSet:b) {
					bSet.addAll(aSet);
				}
				return b;
			}
		} else {
			setsCount++;
			Set<Set<T>> toReturn = new HashSet<Set<T>>(a.size() * b.size());
			for (Set<T> aSet:a ) {
				for (Set<T> bSet:b) {
					Set<T> toAdd = new HashSet<T>(aSet.size() + bSet.size());
					toAdd.addAll(aSet);
					toAdd.addAll(bSet);
					toReturn.add(toAdd);
				}
			}
			return toReturn;
		}
	}
	
	/**
	 * <p>It includes an element in all the sets of the given set.</p>
	 * <p><b>WARNING:</b> it might modify the given sets.</p>
	 * @param <T> Type of the elements.
	 * @param a Element to add.
	 * @param b Set of sets of elements.
	 * @return It returns <code>b</code> with the element included in all its sets.
	 */
	public static <T> Set<Set<T>> cartesianProduct(T a, Set<Set<T>> b) {
		for (Set<T> aSet:b) {
			aSet.add(a);
		}
		return b;
	}
	
	/**
	 * Removes all the supersets of any other set.
	 * @param <T> Class of the values of the inner set.
	 * @param sets Sets to be filtered.
	 * @return A set of sets which no one of them is a superset of the other.
	 * @deprecated This method is not used anymore for its original purpose.
	 */
	@Deprecated
	@SuppressWarnings("unchecked")
	public static <T> Set<Set<T>> removeSuperSets(Set<Set<T>> sets) {
		// @todo This method should be refactorized to a different class.
		Set<Set<T>> toReturn = new HashSet<Set<T>>();
		for (Set<T> toRemove:sets) {
			boolean remove = false;
			for (Set<T> subset:sets) {
				if ((toRemove != subset) && (toRemove.containsAll(subset))) {
					remove = true;
					break;
				}
			}
			if (!remove) {
				toReturn.add(toRemove);
			}
		}
		return toReturn;
	}
}
