/*
 * This file is part of Dinapter.
 *
 *  Dinapter is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Dinapter is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  (C) Copyright 2007 José Antonio Martín Baena
 *  
 *  José Antonio Martín Baena <jose.antonio.martin.baena@gmail.com>
 *  Ernesto Pimentel Sánchez <ernesto@lcc.uma.es>
 */
package dinapter.graph;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

/**
 * Convenient abstract junit test for testing modifiable graph implementations.
 * @author José Antonio Martín Baena
 * @version $Revision: 453 $ - $Date: 2007-02-06 19:08:32 +0100 (mar, 06 feb 2007) $
 * @param <N> Nodes of the graph.
 * @param <G> Class of the graph.
 */
public abstract class ModifiableGraphTestAbstract<N,G extends ModifiableGraph<N>> {
	
    /**
     * Graph to test. 
	 */
	protected G graph = null;
    
    /**
     * List of nodes generated for the test.
     */
	protected List<N> nodes;
	
    /**
     * This factory method generates a graph instance.
     * @return A new graph.
     */
	protected abstract G createGraph();
	
    /**
     * This factory method generates a node instance.
     * All nodes generated by this method must be different from each other.
     * @return A new node.
     */
	protected abstract N createNode();
	
    /**
     * It initializes tests variables.
     * @throws Exception
     */
	@Before
	public void setUp() throws Exception {
		graph = createGraph();
		nodes = new ArrayList<N>(3);
		for (int i = 0; i < 3; i++)
			nodes.add(createNode());
	}

    /**
     * It tests a node removal.
     */
	@Test
	public void testRemoveNode() {
		N from = nodes.get(0);
		N node = nodes.get(1);
		graph.addEdge(from, node);
		graph.addEdge(node, nodes.get(2));
		graph.removeNode(node);
		assertNotSame(nodes.get(1), graph.getChildren(from).isEmpty()?null:graph.getChildren(from).iterator().next());
		assertTrue("The graph should be empty but it had "+graph.getChildren(from).size()+" elements "
				+"(First one:"+(graph.getChildren(from).isEmpty()?"":graph.getChildren(from).iterator().next())+")"
				, graph.getChildren(from).isEmpty());
	}
	
	/**
     * It tests a node removal.
     */
	@Test
	public void testRemoveNodeSeveralChildren() {
		N from = nodes.get(0);
		N node = nodes.get(1);
		graph.addEdge(from, node);
		graph.addEdge(node, nodes.get(2));
		graph.addEdge(node, from);
		graph.removeNode(node);
		assertNotSame(nodes.get(1), graph.getChildren(from).isEmpty()?null:graph.getChildren(from).iterator().next());
		assertTrue("The graph should be empty but it had "+graph.getChildren(from).size()+" elements "
				+"(First one:"+(graph.getChildren(from).isEmpty()?"":graph.getChildren(from).iterator().next())+")"
				, graph.getChildren(from).isEmpty());
	}
	
	/**
     * It tests a node removal.
     */
	@Test
	public void testRemoveNodeSeveralParents() {
		N from = nodes.get(0);
		N node = nodes.get(1);
		graph.addEdge(from, node);
		graph.addEdge(nodes.get(2), node);
		graph.removeNode(node);
		assertNotSame(nodes.get(1), graph.getChildren(from).isEmpty()?null:graph.getChildren(from).iterator().next());
		assertNotSame(nodes.get(1), graph.getChildren(nodes.get(2)).isEmpty()?null:graph.getChildren(nodes.get(2)).iterator().next());
		assertTrue("The graph should be empty but it had "+graph.getChildren(from).size()+" elements "
				+"(First one:"+(graph.getChildren(from).isEmpty()?"":graph.getChildren(from).iterator().next())+")"
				, graph.getChildren(from).isEmpty());
		assertTrue("The graph should be empty but it had "+graph.getChildren(nodes.get(2)).size()+" elements "
				+"(First one:"+(graph.getChildren(nodes.get(2)).isEmpty()?"":graph.getChildren(nodes.get(2)).iterator().next())+")"
				, graph.getChildren(nodes.get(2)).isEmpty());
	}

	/**
     * It tests an edge add. 
	 */
    @Test
	public void testAddEdge() {
		graph.addEdge(nodes.get(0), nodes.get(1));
		assertEquals(1, graph.getChildren(nodes.get(0)).size());
		assertEquals(nodes.get(1), graph.getChildren(nodes.get(0)).iterator().next());
	}

    /**
     * It tests an edge removal.
     */
	@Test
	public void testRemoveEdge() {
		N from = nodes.get(0);
		N to = nodes.get(1);
		graph.addEdge(from, to);
		graph.removeEdge(from,to);
		assertTrue("Graph should be empty but it contains: "+graph.getChildren(from),graph.getChildren(from).isEmpty());
	}

	/**
     * It tests the node children retrieval.
	 */
    @Test
	public void testGetChildren() {
		Set<N> expected = new HashSet<N>(2);
		expected.add(nodes.get(1));
		expected.add(nodes.get(2));
		graph.addEdge(nodes.get(0), nodes.get(1));
		graph.addEdge(nodes.get(0), nodes.get(2));
		assertEquals(expected, new HashSet<N>(graph.getChildren(nodes.get(0))));
	}

    /**
     * It tests the node parents retrieval.
     */
	@Test
	public void testGetParents() {
		Set<N> expected = new HashSet<N>(2);
		expected.add(nodes.get(0));
		expected.add(nodes.get(2));
		graph.addEdge(nodes.get(0), nodes.get(1));
		graph.addEdge(nodes.get(2), nodes.get(1));
		assertEquals(expected, new HashSet<N>(graph.getParents(nodes.get(1))));
	}

	/**
     * It tests the start node retrieval.
	 */
    @Test
	public void testGetStartNode() {
		graph.addEdge(nodes.get(0), nodes.get(1));
		assertEquals(nodes.get(0), graph.getStartNode());
	}

    /**
     * It checks which nodes are within the graph. 
     */
	@Test
	public void testContainsNode() {
		for (int i = 0; i < nodes.size()-1; i++)
			graph.addEdge(nodes.get(i), nodes.get(i+1));
		assertTrue(graph.containsNode(nodes.get(1)));
		assertTrue(!graph.containsNode(createNode()));
	}
	
	/**
	 * It tests the graph inclusion.
	 */
	@Test
	public void testIncludeGraph() {
		int [][] edges = {{0,1},{1,2},{1,0},{1,2},{2,0}};
		G graphA = createGraph();
		G graphB = createGraph();
		G expectedGraph = createGraph();
		int count = 0;
		for (int [] edge:edges) {
			expectedGraph.addEdge(nodes.get(edge[0]), nodes.get(edge[1]));
			if (count++ < 2) {
				graphA.addEdge(nodes.get(edge[0]), nodes.get(edge[1]));
			} else {
				graphB.addEdge(nodes.get(edge[0]), nodes.get(edge[1]));
			}
		}
		graphA.setEndNode(nodes.get(2));
		graphB.setEndNode(nodes.get(0));
		expectedGraph.setEndNode(nodes.get(2));
		
		graphA.includeGraph(graphB);
		assertTrue(expectedGraph.isIsomorphism(graphA));
		// More tests for free ;)
		graphB.includeGraph(graphA);
		assertFalse(expectedGraph.isIsomorphism(graphB));
		graphB.setStartNode(graphA.getStartNode());
		assertFalse(expectedGraph.isIsomorphism(graphB));
		graphB.setEndNode(graphA.getEndNode());
		assertTrue(expectedGraph.isIsomorphism(graphB));
		assertTrue(graphA.isIsomorphism(graphB));
	}
	
}
